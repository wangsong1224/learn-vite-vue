/**
 * HTTP缓存
 * HTTP缓存策略(强制缓存+协商缓存)
 */
/**
 * 什么是缓存?
 * 
 * 为什么要缓存?
 * 现在CPU和渲染速度都很快,瓶颈在网络上,所以减少请求数量,减少包的体积还有HTTP缓存都很重要,
 * 目的就是增加访问速度
 * 
 * 哪些资源可以缓存?
 * 静态资源(js css img)
 * 一般情况下,HTML不适合缓存,随时发版上线之类的更新
 * 网页业务数据也不适合缓存,随时会更改
 */

/**
 * HTTP强制缓存
 * [把图记下来]讲过程
 * 
 * Cache-Control:  max-age:45999(单位是秒) 设置最大过期时间 
 *                  缓存多少秒后过期，过期之后浏览器才会再次发送请求。
 *                 no-cache  不需要强制缓存
 * 
 * Expires  Thu，15 Apr  2010  20：00：00  GMT  设置的是一个具体的过期时间
 * Expires有一个非常大的缺陷，它使用一个固定的时间，
 * 要求服务器与客户端的时钟保持严格的同步，
 * 并且这一天到来后，服务器还得重新设定新的时间。
 * 同为控制缓存过期,
 * 已经被Cache-Control代替了
 * 
 * 如果这两个同时存在,用max-age
 * 
 * 而且如果命中缓存,根本不会向服务器发起请求,浏览器就处理了
 * 所以叫强制缓存
 */

/**
 * 
 * [把图记下来]讲过程
 * 
 * 协商缓存
 * 是个服务端缓存策略,服务端来判断是不是需要缓存
 * 服务端判断客户端资源是不是和服务端资源一样
 * 一致返回304, 否则返回新的资源,新的资源标识
 * 
 * 而资源标识有什么呢
 * 在Response Headers里面
 * last-modified
 * ETag
 * 
 * 在Request Headers里面
 * if-modified-since
 * if-none-match
 * 
 * 这两个道理是一样的,只是标识符不一样
 * 如果共存的话,会优先使用ETag
 * last-modified只能精确到秒级,精度有可能不够,
 * 还有就是资源被重复生成,但是内容不变的情况下,ETag来判断会更准确,因为last-modified
 * 每次都会变
 * 
 */

/**
 * 总的来说,有强缓存用强缓存
 * 没有强缓存或者强缓存过期,看有没有协商缓存
 * 
 * 三种刷新操作对缓存的影响:
 * 1.正常操作:浏览器前进后退,点击链接跳转链接,地址栏输入URL
 * 会命中强制缓存
 * 2.手动刷新:F5刷新,command+R 点击刷新按钮 右键菜单刷新
 * 强制缓存失效,协商缓存有效  想想也是,协商缓存就是一个兜底的作用
 * 3.强制刷新:control+F5 command+shift+R
 * 强制缓存,协商缓存都失效
 * 
 * 清空缓存并进行硬刷新:完全清除页面的缓存并重新下载所有内容。
 */