<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /**
     * 浏览器URL到网页的整个过程
     * 
     * http常见状态码
     * 1xx：临时回应，表示客户端请继续。
     * 2xx：请求成功。200：请求成功。
     * 3xx:表示请求的目标有变化,希望客户端进一步处理
     *     301&302:永久性与临时性跳转
     *     304:跟客户端缓存没有更新
     * 4xx:客户端请求错误
     *     403:无权限
     *     404:请求页面不存在
     * 5xx:服务端请求错误
     *     500:服务端错误
     *     503:服务端暂时性错误,可以一会儿再试
     * 
     * 304又是前端必知必会的,产生这个状态的前提是:客户端本地已经有缓存的版本,并且在request中
     * 告诉了服务端,当服务端通过时间或者Tag,发现没有更新的时候,就会返回一个不含body的304状态
     * 
     * Request Header 字段及含义
     * Accept   浏览器接受的格式 如:application/json, text/plain  
     * Accept-Encoding  浏览器接受的编码方式 如:gzip, deflate, br
     * Accept-Language  浏览器接受的语言,用于判断服务端多语言 如:zh-CN,zh;q=0.9
     * Cache-Control  控制缓存的时效性
     * Connection  连接方式,如果是keep-alive,而且服务端支持,则会复用连接
     * Host  HTTP访问使用的域名
     * Origin scheme(协议)+host(域名)+port(端口),也就是url去掉参数
     * 用来判断是否跨域
     * Reference 当前请求的来源页面
     * If-Modified-Since  上次访问时的更改时间,如果服务端认为此时间后没有更新,则会给出304响应
     * If-None-Match  次访问时使用的E-Tag,通常是页面的信息摘要,这个比更改时间更准确些
     * User-Agent  客户端标识,是一笔糊涂账,好多浏览器这个字段十分复杂,区别微妙
     * Cookie  客户端存储的cookie字段
     * 
     * Response Header 字段及含义
     * Cache-Control 缓存控制,用于通知各级缓存保存时间,例如max-age=0表示不要缓存
     * Connection  连接类型 如果是keep-alive表示复用连接
     * Content-Encoding  内容编码方式 通常是gzip
     * Content-Length  内容长度,有利于浏览器判断内容是否已经结束
     * Content-Type  内容类型,所有请求网页的都是 text/html 还有application/json; charset=utf-8等等
     * Date  当前的服务器日期
     * ETag  页面的信息摘要,用于判断是否需要重新到服务器获取页面
     * Expires  过期时间,用于判断下次请求是否需要到服务端取回页面
     * Keep-Alive 保持连接不断时需要的一些信息,如timeout=5,max=100
     * Last-Modified  页面上次修改的时间
     * Server  服务端软件类型
     * Set-Cookie 设置cookie,可以存在多个
     * Via  服务端请求链路,对一些调试场景至关重要的一个头
     * 
     * HTTP Request Body
     * 常见的Body格式是
     * application/json JSON数据,常用
     * application/x-www-form-urlencoded 使用HTML的form标签提交产生的HTML请求,默认这个格式
     * multipart/form-data  当有文件上传时,会使用
     * text/xml
     * 
     * HTTPS
     * 1.确定请求的目标服务器的身份
     * 2.保证传输的数据不会被网络中间节点窃听或篡改
     * 是使用加密通道来传输HTTP的内容.首先与服务端建立一条TLS加密通道
     * TLS构建与TCP协议之上,它实际上是对传输内容做一次加密,所以从传输内容上来看
     * HTTP与HTTPS没有什么区别
     * 
     * HTTP2
     * 最大的改进有两点
     * 1.支持服务端推送
     * 2.支持TCP连接复用
     * 服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，
     * 放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。
     * TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，
     * 和初建 TCP 连接时传输窗口小的问题。
     * 
     * 解析代码
     * DOM构建过程
     * 1.token如何被拆分
     * 例如 <p class='p'>text text</p>
     * 最小的有意义的单元应该是<p , 这里要用到状态机
     * 实现方式大同小异, 我们把每个函数当成一个状态,参数是接收的字符串,返回值是下一个函数
     * 2.构建DOM树
     * 构建DOM树是用栈来实现的,根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。
     * 栈顶元素就是当前节点
     * 遇到属性,直接添加到这个节点
     * 遇到文本节点,如果当前节点是文本节点就合并,否则入栈成为当前节点的子节点
     * 遇到注释节点,成为当前节点子节点
     * 遇到tag start就入栈一个节点,当前节点就是这个节点的父节点
     * 遇到tag end就出栈一个节点(HTML容错能力强,就是在于tag end 和tag start不匹配的时候的处理)
     * 
     * 上面构建DOM的过程是不完整的,它只有节点和属性,不包含任何样式信息
     * CSS构建过程
     * 浏览器会尽量流式处理整个过程,在这个过程中,我们拿到构造好的元素,去检查它匹配到了哪些规则,
     * 再根据规则的优先级,做覆盖和调整
     * 
     * 排版过程
     * 浏览器又可以支持元素和文字的混排，元素被定义为占据长方形的区域，
     * 还允许边框、边距和留白，这个就是所谓的盒模型。
     * 在正常流的基础上,浏览器还有两类元素:绝对定位元素和浮动元素
     * 绝对定位元素从正常流中抽出,不参加排版计算,也不影响其他元素
     * 浮动元素是使自己在正常流的位置向左或向右移动到边界,并且占据一块排版空间
     * 
     * 渲染过程
     * 就是把模型变成位图的过程
     * 位图:内存里建立一张二维表格,把一张图片每个像素的颜色信息保存进去
     * 位图信息也是DOM树中占据浏览器内存最多的信息,我们在做内存优化时,主要就是考虑这部分
     * 浏览器渲染这个过程就是把每个元素对应的盒变成位图
     * 过程非常复杂,总体来说可分为 图形和文字两大类
     * 盒中的文字，也需要用底层库来支持，叫做字体库
     * 
     * 合成过程
     * 合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），
     * 把一部分子元素渲染到合成的位图上面。
     * 合成是一个性能考量，那么合成的目标就是提高性能，
     * 根据这个目标，我们建立的原则就是最大限度减少绘制次数原则。
     * 好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。
     * 主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。
     * 这样的猜测准确性有限，所以新的 CSS 标准中，规定了 [will-change] 属性，
     * 可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。
     * 
     * 绘制过程
     * 绘制是把位图最终绘制到屏幕上,变成肉眼可见的图像的过程
     * 浏览器只需要把内存中的一张位图提交给操作系统或者驱动就可以了
     * 
    */

    /**
     * 事件循环EventLoop
     * 基于EventLoop实现了异步回调,是为了解决JavaScript单线程任务执行阻塞的问题
     * 
     * 每个渲染进程都有一个[主线程],它要处理很多事儿,比如DOM,计算样式,布局,JavaScript任务和事件
     * 需要一个系统来统筹调度这些任务,这个系统就是[消息队列]和[事件循环]
     * 
     * 主要有三大块
     * 浏览器工作原理 https://time.geekbang.org/column/article/132931
     * 1.主线程上有EventLoop,它不停地从任务队列头部取出任务并执行
     * 2.任务队列接受各种事件,网络请求等事件 其中包含宏任务和微任务
     * 3.IO线程 中产生的新任务添加进任务队列的尾部
    */
    function foo() {
      var a = 1
      let b = 2
      {
        let b = 3
        var c = 4
        let d = 5
        console.log(a)
        console.log(b)
      }
      console.log(b)
      console.log(c)
      console.log(d)
    }
    foo()
  </script>
</body>

</html>