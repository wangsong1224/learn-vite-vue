<template></template>
<script>
export default {
  name: "",
};
/**
 * vue和React对比
 * 机制不同
 * vue使用了响应式数据,用来监测数据的变化,用通知的方式更新组件
 * React是用找出虚拟DOM 新旧数据的diff来更新
 *
 * vue采用新建watcher的方式进行监听,这本身就很消耗性能,监听器过多会影响性能
 * React的diff算法,当虚拟DOM比较大时,计算时间可能大于渲染的时间间隔(16.6ms)时,就会造成卡顿
 *
 * 为了解决性能瓶颈,它们走上了不同的道路
 * react 借鉴了操作系统时间分片的概念,引入了fiber架构,把整个虚拟DOM树微观化,变成链表,
 * 然后利用浏览器的空闲时间计算diff 一旦浏览器有需求,我们可以把主进程控制权交还给浏览器,
 * 等待浏览器下次空闲
 *
 * vue1的问题在于响应式过多,会带来内存占用过多的问题,vue2引入了虚拟DOM
 * 响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 Diff，一个推一个拉，它们看起来是两个方向的技术，
 * 但被 Vue 2 很好地融合在一起，采用的方式就是组件级别的划分。
 * 对vue2来说,组件之间的变化,可以通过响应式来通知更新
 * 组件内部的变化,则通过虚拟DOM去更新
 * 这样就把响应式的监听器控制在了组件级别,而虚拟DOM的量级也控制在了组件的大小
 *
 * vue2的实现里面大概分四步:
 * 1.mvvm用来初始化数据
 * 2.observer用来对初始数据通过Object.defineProperty添加setter和getter，
 * 当取数据（即调用get）的时候添加订阅对象（watcher）到数组里，
 * 当给数据赋值（即调用set）的时候就能知道数据的变化，
 * 此时调用发布订阅中心的notify，从而遍历当前这个数据的订阅数组，
 * 执行里面所有的watcher，通知变化update。
 * 3.compiler是用来把data编译到dom中。
 * 分三步：1.先把真实的dom移入到内存中 fragment，
 * 2.编译：提取想要的元素节点v-model和文本节点{{}}；
 * 3.把编译好的fragment塞回到页面去。
 * 第二步骤中会对编译到dom中的data添加watcher,当data变化时，这里的watcher回调也能收到通知得到执行。
 * watcher是observer和compiler之间通信的桥梁。
 *
 * vue2还是有缺陷的
 * 1.Vue 2 响应式并不是真正意义上的代理，而是基于 Object.defineProperty() 数据劫持实现的。
 *  只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。
 * 2. Option API 在组织代码较多组件的时候不易维护。对于 Option API 来说，所有的 methods、computed 都在一个对象里配置，
 * 这对小应用来说还好。但代码超过 300 行的时候，新增或者修改一个功能，就需要不停地在 data，methods 里跳转写代码，我称之为上下反复横跳。
 * 3. 当项目里“读取 obj.title”和“修改 obj.title”的时候被 defineProperty 拦截，
 * 但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。
 *
 *
 * vue3的特点:
 * 1.使用Proxy做拦截,可以拦截对象的所有属性 还可以监听更多的数据格式,如Map Set等
 * 2.自定义渲染器 新的架构中,响应式独立出来了,渲染的逻辑也拆成了浏览器渲染api 和 平台无关渲染逻辑
 * 3.全部模块使用TS重构
 * 4.组合式API
 *  为什么组合式API改写法了
 *  1.Option API的所有数据都挂在在 this 上,导致对TS类型推断很不友好,也不利于Tree-Shaking清理代码
 *  2.data,methods 分隔开之后,组件大了之后,会上下反复横跳
 *  3.对代码复用很不友好,只能用mixin
 * 组合式API可以 把功能模块的方法,属性都放到一起,还可以导出功能模块方便复用,
 * 5.新的组件
 *  Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。
 *  Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。
 *  Suspense: 异步组件，更方便开发有异步请求的组件。
 *
 * vite和webpack对比
 * webpack 是根据import依赖逻辑生成依赖地图,然后调用对应的loader处理,把整个项目打包后放到内存再启动
 * vite 主要提升的是开发体验,很多浏览器已经默认支持import语法,所以vite根本不需要全部打包,只把首页依赖的
 * 文件,依次通过网络请求去获取,对大型项目做到了很快的启动和热更新
 *
 */

/**
 * vue中 computed watch methods
 * methods就是函数,不能像computed那样自动运行
 * computed 是根据依赖的状态变化时候自动计算生成新状态的一种方法,
 * 所以当你需要生成一个新状态时,用computed
 * watch 不会返回一个新的状态,比较适合监控某一个状态变化后,做一些副作用操作,
 * 比如网络请求,业务逻辑处理等
 */
</script>
<style lang="less"></style>
